\documentclass[12pt,letterpaper]{article}

\usepackage[margin=1in]{geometry}

\begin{document}

\begin{flushright}
Homework 2: SSA, Constant Propagation, and Value Numbering\\
Paul Vines and Eric Mullen\\
CSE 501\\
\end{flushright}

Implementation of Constant Propagation:
Constants Propagation was performed on the SSA-form instructions by adding a lattice-cell value to each instruction in a wrapper expression class. Expressions are stored in a HashMap keyed by the instruction number, except Move expressions, which are keyed by the hashcode of the variable they are being stored in. When constructing these expression objects the lattice value is assigned based on the instruction type and operands: 
Arithmetic instructions, comparison, moves, and stores, are initialized to Top unless all operands are Const, then Const
Phi instructions are assigned Top
All other operands are assigned Bottom, as they either do not have results that are in scope of intraprocedural analysis or should not ever be used as an operand (e.g. Write).

All expression that are constants are analyzed to determine their constant value by inspecting their operands (Immediates at this point) and performing the computation associated with their instruction and storing the results in the expression object.

The SSA edges list is a HashMap of sets of expressions keyed by an expression. It is constructed by iterating through all expressions, for each operand in the expression, the set corresponding to that operand is retrieved and the expression is added to the set, indicating this expression is affected by the value of the expression corresponding to its operand. O(n)

After expressions and the SSA Edges have been constructed, every SSA Edge keyed to a non-Top variable is added to the worklist queue.
Until the worklist is not empty, an SSA Edge is dequeueued. The value of the destination of the edge is reevaluated based on the source. If the source is a Bottom, the destination becomes Bottom. If the source is Const then, unless the destination is a Phi node or is Bottom, the destination is set to Const. If the destination is a Phi then the lattice value is reduced to Bottom unless all operands of the Phi node are Const and have the same Const values. Because of this, all Phi node evaluation is delayed until either all the Phi node arguments are non-Top or only Phi nodes. 
If an expression is made Const then its value is determined based on the values of its operands. 

After the worklist is empty all expressions will now have a non-Top lattice value. All arithmetic expressions with Const operands have their operand replaced with Immediates of the correct value. Conditional branches with Const conditiona operands are replaced with unconditional branches or nops.
After constant operands have been replaced, all Const instructions can be removed, unless they are used in a non-Const Phi node.


\end{document}
